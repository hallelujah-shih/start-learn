# 一次由TLS密钥交换算法X448引发的“血案”

## 一、引言
    有报告称系统上某特定节点出现了访问异常，而其他通用节点却是正常的。通过查看报告内容可以知道是用户的下发任务执行失败，而售后通过curl指定源站进行访问报错：unknow ca。

## 二、排查之旅：抽丝剥茧
* **现象：** 售后的curl截图报告以及抓包信息中的Alert信息：Unknown CA，然后RST了通信。
* **初步判断：** 根据售后的报告信息和抓包信息，基本可以确定是一起典型的服务端证书链不完整引起的。
* **验证：** 通过pcap包，找到Server Hello,并在证书列表中只看到了一个证书（基本可以确定），然后导出核对，的确如此，并告知售后通知客户补齐证书链重启服务端服务。
* **后续：** 当客户补齐证书后，下发任务的执行还是异常，但是异常已经发生了变化，为 **Description: Illegal Parameter** 了，因为对整个项目的流程和组件均不熟悉，所以就从任务的组件进行剥离+测试（悲剧的开始）。
* **制定排查计划：**
    * 组件关系分析：组件是通过chromedp，再通过chromedp的MAP特性进行请求代理
    * 分别排查chromedp以及特定版本的golang的通信是否有同样的问题
* **实施：**
    * 用LLM来实现一个极简的 go + chromedp 爬虫，分析是否是 chromedp + chrome 造成的，参见[code](./code)。发现没有问题，并调整版本与线上版本一模一样后依然没有问题。
    * 排查Go语言是否会造成此问题。发现不同版本均没有问题。
    * 排查chromedp中map指向的服务。docker内部指向了宿主机上的nginx服务，然后通过nginx的错误日志中发现了问题。所以引起问题的组件实际为nginx，而nginx的ssl是静态编译的，且配置中是ignore了服务端证书的验证的，所以第一次报告的问题用curl进行排查并抓包，本身就将问题带偏了。
    * 进一步排查：先将nginx所用版本的openssl进行编译，使得生成openssl工具，好进行验证。[Dockerfile.openssl](./Dockerfile.openssl)，发现了问题，与描述的一致，并发现是密钥交换协商过程中所用算法X448引发，手动写代码，并通过函数 **SSL_CTX_set1_groups_list** 禁用X448后，发现问题解决（初步得出结论，客户端侧或者服务端侧有一方的X448算法有bug）。
    * 再进一步排查：拉取最新的openssl的1.1.1的版本以及openssl的3.5的版本以及curl的最新版本，进行测试，均发现有问题。我们的openssl版本再与openssl中3.5最新版本做curve 448的测试，均没有问题，所以进一步确定是服务端的X448算法有bug（还没完...）。
    * 给出解决方案：服务端禁用X448算法，或者更换新的openssl版本来解决这个问题（以为结束了，其实还没有）。
* **售后的补充反馈：** 历史上出现过一次同样的问题**Description: Illegal Parameter**，只是他也忘记了，没能联系在一起，是某银行实施国密时碰到的错误，最后的解决方案是禁用了X448算法。
* **思考：**
  * 为什么Golang语言访问不会有问题？
  * 为什么Chrome访问没问题？
  * 为什么是国密上报错？

## 三、根本原因：揭开谜底
我们来回答下面的问题：
* 为什么Golang语言访问不会有问题？
    通过抓包分析，发现Golang语言在创建TLS连接时，握手参数中extension.supported_groups中并没有X448，并在Golang的仓库中发现了Issue：[issues/29390](https://github.com/golang/go/issues/29390)，发现Golang并未实现X448算法，所以Golang访问无问题。

* 为什么Chrome访问没问题？
    通过抓包分析，发现Chrome在创建TLS连接时，握手参数中extension.supported_groups中也没有X448，在Chrome中使用的是BoringSSL，通过查找代码发现BoringSSL也没有实现X448算法：[openssl/evp.h#L1025](https://github.com/google/boringssl/blob/main/include/openssl/evp.h#L1025),所以Chrome浏览器访问也没问题。

* 为什么是国密上报错？
    首先我们需要了解X448算法，X448算法首先是来自于X25519，甚至448算法组都没办法在编译时单独隔离，他们有不少代码复用。其次X448算法中的448就是448位，即56字节。通过抓包发现服务端选择X448时候返回了65字节，这时候我们不得不怀疑服务端在X448算法的实现上存在bug的问题，可能不是X448算法本身的bug，而是另外有原因，毕竟这种位数规范都差异这么大。
    我们既然知道了服务端是双栈的SSL，那么我们从国密入手看问题出在哪儿。通过仓库[GmSSL](https://github.com/GmTLS/GmSSL.git)，我们跟踪了文件 gmssl/tls.h 中的 TLS_NAMED_CURVE 的枚举定义，发现这个枚举定义在2022年6月13日前，TLS_curve_x448 的值被定义为了99，而此值在 openssl的文件t1_lib.c中定义的eccurves_default中能发现为30。而国密将原先应该分配给X448算法的编号30分配给了sm2，而将X448分配为了99，所以通信是造成错误的根本原因。而在2022年6月13日后，注释中发现将x448改回了30，将sm2改为了41，注释中写明了与其支持v2，还不如直接修改v2,让v2和v3支持，从这句话中我们可以知道应该是涉及国密的版本迭代问题，而新版本与openssl本身是没有冲突的，或者说国际规范上是没有冲突的。
    总结：服务端的SSL网关版本较老，使得x448算法在编号上与openssl等国际规范上规定的编号冲突，导致通信出现问题。

## 四、解决方案
1. 禁用X448算法，或者更换新的国密版本来解决这个问题。

## 五、总结与反思
此次事件首先从一个看起来非常简单的问题牵扯了一堆问题，浪费了大量时间，并走了不少弯路。首先根本问题上来就直接被带偏了，哪怕用curl进行测试，相似的行为应该是加上-k参数进行测试。其次nginx本身使用的openssl与curl所用的openssl差异巨大，没有直接的可比性。还有个问题就是从每个组件进行了排查，因为不熟悉系统，内心直接给执行任务的模块判定了有罪，导致绕了一个大弯。

* 应该先了解整个系统的流程，而不是根据售后的报告信息顺着这条路进行排查（比如售后的curl并未加参数-k，而业务）。
* 排查问题的第一要素永远是通过日志分析，一定是要核查到每个组件的日志情况，并在日志无果的情况下进行组件的深入分析。
